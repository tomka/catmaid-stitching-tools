import ij.*;
import ij.io.*;
import ij.process.*;

import loci.plugins.util.*;
import loci.formats.*;
import loci.formats.meta.*;
import ome.xml.model.primitives.PositiveFloat;
import java.util.Arrays;
import java.util.HashMap;
import mpicbg.ij.integral.*;

int tileSize = 256;
int thumbnailSize = 192;
//int numScaleLevels = -1; // ...compute from image height
int numScaleLevels = 4;
String overviewName = "small";
float unitConvFactor = 1000.0;
int maxValue = 4095;
String inputFile = "totile.txt";
boolean useGeneratedInfo = false;
boolean createZProjections = false;
boolean grayscaleSingleChannels = false;
ArrayList channels, colors, names;
ImagePlus imp = null;

MetadataRetrieve getMetaData( pathName )
{
	ImageProcessorReader r = new ImageProcessorReader( new ChannelSeparator( LociPrefs.makeImageReader() ) );
	MetadataStore store = MetadataTools.createOMEXMLMetadata();
	r.setMetadataStore( store );
	try
	{
		r.setId( pathName );
		MetadataRetrieve retrieve = MetadataTools.asRetrieve( r.getMetadataStore() );
		return retrieve;
	}
	catch ( FormatException exc )
	{
		IJ.error("FormatException: Sorry, an error occurred: " + exc.getMessage());
	}
	catch ( IOException exc )
	{
		IJ.error("IOException: Sorry, an error occurred: " + exc.getMessage());
	}
	return null;
}

ImagePlus openImage( pathName )
{
	ImageProcessorReader r = new ImageProcessorReader( new ChannelSeparator( LociPrefs.makeImageReader() ) );
	MetadataStore store = MetadataTools.createOMEXMLMetadata();
	r.setMetadataStore( store );
	CompositeImage openedImage = null;
	try
	{
		r.setId( pathName );
		MetadataRetrieve retrieve = MetadataTools.asRetrieve( r.getMetadataStore() );

		PositiveFloat pw = retrieve.getPixelsPhysicalSizeX( 0 );
		pw = pw == null ? new PositiveFloat( 1.0 ) : pw;
		PositiveFloat ph = retrieve.getPixelsPhysicalSizeY( 0 );
		ph = ph == null ? new PositiveFloat( 1.0 ) : ph;
		PositiveFloat pd = retrieve.getPixelsPhysicalSizeZ( 0 );
		pd = pd == null ? new PositiveFloat( 1.0 ) : pd;
		Double pt = retrieve.getPixelsTimeIncrement( 0 );
		pt = pt == null ? new Double( 1.0 ) : pt;
		
		n = r.getImageCount();
		w = r.getSizeX();
		h = r.getSizeY();
		l = r.getSizeT();
		d = r.getSizeZ();
		s = r.getSizeC();
		IJ.log("Reading image with " + n + " planes, a size of " + w + "x" + h +
			"x" + d + ", " + l + " time point(s) and " + s + " color channels");

		stack = new ImageStack( w, h );
		lookupTable = new byte[ r.getSizeC() ][][];
		for ( int t = 0; t < l; ++t )
			for ( int z = 0; z < d; ++z )
				for ( int c = 0; c < s; ++c )
				{
					i = t * d * s + z * s + c;
					ip = r.openProcessors( i )[ 0 ];
					stack.addSlice( "" + ( i + 1 ), ip );
					ci = r.getZCTCoords( i )[ 1 ];
					lookupTable[ ci ] = r.get8BitLookupTable();
				}
		imp = new ImagePlus( pathName, stack );
		calibration = imp.getCalibration();
		calibration.pixelWidth = pw.getValue();
		calibration.pixelHeight = ph.getValue();
		calibration.pixelDepth = pd.getValue();
		calibration.frameInterval = pt.doubleValue();
		calibration.setUnit( "um" );
		imp.setDimensions( r.getSizeC(), r.getSizeZ(), r.getSizeT() );
		imp.setOpenAsHyperStack( true );
		openedImage = new CompositeImage( imp );
		openedImage.setMode( CompositeImage.COMPOSITE );
	}
	catch ( FormatException exc )
	{
		IJ.error("FormatException: Sorry, an error occurred: " + exc.getMessage());
	}
	catch ( IOException exc )
	{
		IJ.error("IOException: Sorry, an error occurred: " + exc.getMessage());
	}
	return openedImage;
}

/**
 * crop a tile from a ColorProcessor.
 *
 * @param tileWidth    width of a tile
 * @param tileHieght   height of a tile
 * @param tileIndexX   grid index of the tile to crop
 * @param tileIndexY   grid index of the tile to crop
 */
ColorProcessor getTile( ColorProcessor cp, int tileWidth, int tileHeight, int tileIndexX, int tileIndexY )
{
	int x = tileWidth * tileIndexX;
	int y = tileHeight * tileIndexY;
	cp.setRoi( x, y, tileWidth, tileHeight );
	ColorProcessor cpTile = cp.crop();
	// make sure the new tile is of the correct size
	if (cpTile.getWidth() != tileWidth || cpTile.getHeight() != tileHeight) {
		ColorProcessor cpTileNew = cpTile.createProcessor(tileWidth, tileHeight);
		cpTileNew.setColor(0);
		cpTileNew.fill();
		cpTileNew.copyBits(cpTile, 0, 0, Blitter.COPY);
		cpTile = cpTileNew;
	}
	return cpTile;
}

/**
 * choose the number of scale levels required to fit the
 * image height into 2*tile_size at the highest level.
 */
int getNumScaleLevels( int height, int tileSize )
{
	double s = Math.log( (double)height / (double)tileSize ) / Math.log( 2 );
	if ( s < 1 )
		return 1;
	else if ( (int) s == s )
		return (int) s;
	else
		return (int) s + 1;
}

void createTiles() {
	int numSlices = imp.getNSlices();
	int tileWidth = tileSize;
	int tileHeight = tileSize;
	if ( numScaleLevels == -1 )
		numScaleLevels = getNumScaleLevels( imp.getHeight(), tileSize );

	IJ.log( "computing tiles for "+numScaleLevels+" scale levels, "+numSlices+" slices" );

	int lastStep = 0;
	for ( int sliceIndex = 0; sliceIndex < numSlices; ++sliceIndex )
	{
		// expect a hyper stack and set slice accordingly"
		imp.setPosition(1, sliceIndex+1, 1);
		imp.updateImage();
		ColorProcessor cpSlice = new ColorProcessor( imp.getImage() );
		cpSliceScale = new Scale( cpSlice );

		for ( int scaleLevel = 0; scaleLevel < numScaleLevels; ++scaleLevel )
		{
			int width = imp.getWidth() / Math.pow( 2, scaleLevel );
			int height = imp.getHeight() / Math.pow( 2, scaleLevel );
			ColorProcessor cp = cpSliceScale.scale( width, height );

			int cols = ( width / tileWidth );
			if ( width > cols * tileWidth )
				++cols;
			int rows = ( height / tileHeight );
			if ( height > rows * tileHeight )
				++rows;
			
			sliceDirName = stackDirName + "/" + sliceIndex;

			// create tiles
			for ( int tileIndexY = 0; tileIndexY < rows; ++tileIndexY )
			{
				for ( int tileIndexX = 0; tileIndexX < cols; ++tileIndexX )
				{
					cpTile = getTile( cp, tileWidth, tileHeight, tileIndexX, tileIndexY );
					ip = new ImagePlus( "" + tileIndexY + ", " + tileIndexX, cpTile );
					//tileDirName = sliceDirName + "/" + scaleLevel + "/" + tileIndexY;
					//tileFileName = tileDirName + "/" + tileIndexX + ".jpg";
					tileDirName = sliceDirName + "/";
					tileFileName = tileDirName + tileIndexY + "_" + tileIndexX + "_" + scaleLevel + ".jpg";
					// IJ.log( "writing " + tileFileName );
					new File( tileDirName ).mkdirs();
					saver = new FileSaver( ip );
					saver.saveAsJpeg( tileFileName );
				}
			}

			// create overview image
			int width = imp.getWidth();
			int height = imp.getHeight();
			if ( width > height )
			{
				height = (height * thumbnailSize) / width;
				width = thumbnailSize;
			}
			else
			{
				width = (width * thumbnailSize) / height;
				height = thumbnailSize;
			}
			cpOverview = cpSliceScale.scale( width, height );
			ip = new ImagePlus( "overview", cpOverview );
			overviewFileName = sliceDirName + "/" + overviewName + ".jpg";
			saver = new FileSaver( ip );
			saver.saveAsJpeg( overviewFileName );
		}

		percent = (int) ( ((sliceIndex + 1) / (float) numSlices) * 100.0 + 0.5 );
		diff = percent - lastStep;
		if ( diff >= 10  || percent == 100 ) {
			lastStep += (int)diff;
			//lastStep = Math.min( 100, lastStep );
			IJ.log(lastStep + "% completed");
		}
	}
}

void tileSingleImage(imgFileName) {
	imgFile = new File( imgFileName );
	if ( ! imgFile.exists() || ! imgFile.isFile() )
	{
		IJ.log( "File `" + imgFileName + "' not found." );
		return;
	}
	imp = openImage ( imgFileName );
	if ( imp == null )
	{
		IJ.log( "File `" + imgFileName + "' could not be opened." );
		return;
	}
	createTiles();
}

String getChannelName(num, postfix) {
	return "-ch" + num + postfix + ".tif";
}

public class ImageInfo {
	public ArrayList images;
	public String info;

	public ImageInfo(ArrayList list, String info) {
		this.images = list;
		this.info = info;
	}

	public ImageInfo(ArrayList list) {
		this.images = list;
		this.info = "None";
	}
}

ImageInfo preProcess(imgFileName, wantedChannels, colors) {
	// Make sure we only ask for channels that are available
	metadata = getMetaData( imgFileName );
	availableChannels = metadata.getChannelCount(0);
	channels = new ArrayList();
	for (int i=0; i<wantedChannels.size(); ++i) {
		ch = wantedChannels.get(i);
		if (ch <= availableChannels) {
			channels.add(ch);
		} else {
			IJ.log("Dropping request for channel " + ch + " as it is not available.");
		}
	}

	returnList = new ArrayList();
	// check if enough colors are available
	numChannels = channels.size();
	if (numChannels > colors.size()) {
		IJ.log("Got only " + colors.length() + " colors, but would need " + numChannels);
		return null;
	}
	// remove the extension from the file name
	imgFileNameBase = imgFileName.substring(0, imgFileName.lastIndexOf('.'));
	// create names for different channels
	compositeName = imgFileNameBase + "-composite.tif";

	IJ.log("Preprocessing image " + imgFileName);
	macro = "setBatchMode(true);\n"
		+"run(\"Bio-Formats\", \"open=[" + imgFileName + "] view=Hyperstack stack_order=XYCZT display_metadata=false\");\n"
		+"Stack.setDisplayMode(\"color\");\n"
		+"Stack.getDimensions(width, height, channels, slices, frames);\n";
		//+"open(\"" + imgFileName + "\");\n";
	if (useGeneratedInfo) {
		// get dimension and resolution info
		macro += "getPixelSize(unit, pw, ph, pd);\n"
			+"factor = " + unitConvFactor + ";\n"
			+"dimStr = \"dimension: (\" + width + \",\" + height + \",\" + slices + \")\";\n"
			+"resStr = \"resolution: (\" + pw*factor + \",\" + ph*factor + \",\" + pd*factor + \")\";\n"
			+"infoStr = dimStr + \"\\n\" + resStr + \"\\n\";\n";
	}

	macro += "wantedChannels = newArray(channels);\n"
		+"Array.fill(wantedChannels, 0);\n";

	// prepare channels
	for (int i=0; i<numChannels; ++i) {
		ch = channels.get(i);
		macro += "if (" + ch + " <= channels) {"
			+" Stack.setChannel(" + ch  + ");\n"
			+" setMinAndMax(0, " + maxValue + ");\n"
			+" run(\"" + colors.get(i) + "\");\n"
			+" wantedChannels[" + (ch - 1) + "]=1;\n"
			+"}";
	}

	// create a string describing which channels to use
	macro += "activeChannels = \"\";\n"
		+"for (i=0; i<channels; i++) {\n"
		+"  activeChannels = activeChannels + wantedChannels[i];\n"
		+"}";

	// create composite
	// Make only the channels active that we want
	macro += "Stack.setDisplayMode(\"composite\");\n"
		+"Stack.setActiveChannels(activeChannels);\n"
		+"run(\"Stack to RGB\", \"slices keep\");\n"
		+"saveAs(\"Tiff\", \"" + compositeName + "\");\n";
	returnList.add(compositeName);
	if (createZProjections) {
		fileName = imgFileNameBase + "-composite-zproj.tif";
		returnList.add(fileName);
		macro += "run(\"Z Project...\", \"start=1 stop=\" + slices + \" projection=[Average Intensity]\");\n"
			+"saveAs(\"Tiff\", \"" + fileName + "\");\n"
			+"close();\n";
	}
	// close the RGB image
	macro += "close();\n";

	macro += "run(\"Split Channels\");\n";

	// create single channels
	macro += "channelNames = newArray(channels);\n";
	macro += "channelNamesZProj = newArray(channels);\n";
	for (int i=0; i<numChannels; ++i) {
		// save the channels in reverse
		ch = channels.get(i);
		chName = imgFileNameBase + getChannelName(ch, "");
		returnList.add(chName);
		macro += "channelNames[" + (ch - 1) + "] = \"" + chName + "\";\n";
		if (createZProjections) {
			chName = imgFileNameBase + getChannelName(ch, "-zproj");
			returnList.add(chName);
			macro += "channelNamesZProj[" + (ch - 1) + "] = \"" + chName + "\";\n";
		}
	}

	macro += "for (i=0; i<channels; i++) {\n"
		+"  ch = channels - i - 1;\n"
		+"  if (wantedChannels[ch]==1) {\n"
		+"    run(\"8-bit\");\n";
	if (grayscaleSingleChannels)
		macro += "    run(\"Grays\");\n";
	macro += "    saveAs(\"Tiff\", channelNames[ch]);\n";
	if (createZProjections) {
		macro += "run(\"Z Project...\", \"start=1 stop=\" + slices + \" projection=[Average Intensity]\");\n"
			   + "saveAs(\"Tiff\", channelNamesZProj[ch]);\n";
	}
	macro +="  }\n"
		+"  close();\n"
		+"}\n";

	if (useGeneratedInfo)
		macro += "return infoStr;\n";

	output = IJ.runMacro(macro);
	if (useGeneratedInfo) {
		IJ.log("Output of macro: " + output);
		return new ImageInfo(returnList, output);
	} else {
		return new ImageInfo(returnList);
	}
}

public class NamedImage {
	String path;
	String name;
	public NamedImage(String path, String name) {
		this.path = path;
		this.name = name;
	}
}

void work() {
	if ( singleFile != null ) {
		tileSingleImage( singleFile );
	} else {
		IJ.log("Tiling channels " + channels.toString() + " (or less if less available) of an image with max. value " + maxValue);
		if (useGeneratedInfo)
			IJ.log("Will generate info.yml from file data");
		// look for names
		names = new ArrayList();
		if (useGeneratedInfo) {
			nf = new File("names.txt");
			if (nf.exists()) {
				// read in name definitions from file
				fstream = new FileInputStream(nf);
				in = new DataInputStream(fstream);
				br = new BufferedReader(new InputStreamReader(in));
				String strLine;
				while ((strLine = br.readLine()) != null) {
					names.add(strLine);
				}
				in.close();
			} else {
				IJ.log("No name file found (names.txt)");
				return;
			}
		}
		// look for files to tile
		f = new File( inputFile );
		if (f.exists()) {
			try {
				rawImages = new ArrayList();
				// look for a list of images to work on
				fstream = new FileInputStream(f);
				in = new DataInputStream(fstream);
				br = new BufferedReader(new InputStreamReader(in));
				String strLine;
				while ((strLine = br.readLine()) != null) {
					// skip comments (lines starting with #)
					if (strLine.trim().startsWith("#"))
						continue;
					// try to treat line as file path
					imgFile = new File(strLine);
					if (imgFile.exists()) {
						IJ.log("found file " + strLine);
						rawImages.add(strLine);
					} else {
						IJ.log("could not find file " + strLine);
					}
				}
				in.close();
				namedImages = new ArrayList();
				if (useGeneratedInfo) {
					// check if every file has a name
					if (rawImages.size() != names.size()) {
						IJ.log("The number of names differs from the number of files");
						return;
					}
					for (i=0; i<rawImages.size(); ++i) {
						namedImages.add(new NamedImage(rawImages.get(i), names.get(i)));
					}
				} else {
					for (i=0; i<rawImages.size(); ++i) {
						namedImages.add(new NamedImage(rawImages.get(i), "No Name"));
					}
				}
				// Open every image, reset the dynamic range,
				// create a composite and all single channel images,
				// save them and then tile them
				for(ni : namedImages) {
					imageInfo = preProcess(ni.path, channels, colors);
					originalImg = new File(ni.path);
					originalDir = originalImg.getParent();
					// prepare image info
					info = "";
					infoAvailable = false;
					if (useGeneratedInfo) {
						info = imageInfo.info;
						// append a name
						info += "name: " + ni.name;
						infoAvailable = true;
					} else {
						// look for info.yml
						infoFile = new File(originalDir + "/info.yml");
						infoAvailable = infoFile.exists();
						if (infoAvailable) {
							IJ.log("Info file found");
							// read in info file
							ifstream = new FileInputStream(infoFile);
							iin = new DataInputStream(ifstream);
							ibr = new BufferedReader(new InputStreamReader(iin));
							String strLine;
							while ((strLine = ibr.readLine()) != null) {
								info += strLine + "\n";
							}
							iin.close();
						} else {
							IJ.log("Info file not found");
						}
					}
					// tile all the images
					for (i : imageInfo.images) {
						imgFile = new File(i);
						// cut away the file extension
						imgBaseName = imgFile.getName().substring(0, imgFile.getName().lastIndexOf('.'));
						// cut away the channel information
						chInfoIndex = imgBaseName.lastIndexOf('-');
						chInfo = imgBaseName.substring(chInfoIndex, imgBaseName.length());
						imgInfo = imgBaseName.substring(0, chInfoIndex);
						stackDirName = "./tile_output/" + imgBaseName + "/";
						imgDir = new File(stackDirName);
						// Check if the folder already exists. If so, add a counter.
						counter = 2;
						while (imgDir.exists()) {
							// rename the output folder from imgName-chInfo to imgName_counter-chInfo
							stackDirName = "./tile_output/" + imgInfo + "_" + counter  + chInfo + "/";
							imgDir = new File(stackDirName);
							counter++;
						}
						IJ.log("Using output dir: " + stackDirName);
						// create folder for the new tiles
						imgDir.mkdirs();
						// tile the image
						tileSingleImage(i);
						// write out info string
						if (infoAvailable) {
							File outputFile = new File(stackDirName + "info.yml");
							FileWriter out = new FileWriter(outputFile);
							BufferedWriter bout = new BufferedWriter(out);
							bout.write(info);
							bout.close();
						}
						// finally remove the image
						imgFile.delete();
					}
				}
			} catch (e) {
				System.err.println("Error: " + e.getMessage());
				e.printStackTrace();
			}
		}
	}
}

void setup( options ) {
	// check what options are available

	// help
	if ( options.containsKey( "synopsis") || options.containsKey( "help" ) ) {
		IJ.log( "This script tiles one or more files for the use with CATMAID" );
		IJ.log( "You can pass the following arguments and options to the script:" );
		IJ.log( "-ch <list of channels>   -- Define which channels to use, e.g. -ch \"1,2\"" );
		IJ.log( "-clr <list of colors>    -- Define a list of ImageJ colors to be used for the channels, e.g. -clr \"Green, Magenta\"" );
		IJ.log( "-max-val <value>         -- The maximum value for dynamic range adjustments, e.g. -max-val 4095" );
		IJ.log( "-target-dir <dir>        -- Define the directory in which the result should be saved" );
		IJ.log( "--gen-info               -- Let the tool generate some meta data, saved in file info.yaml" );
		IJ.log( "--z-project              -- Let the tool do a z-projection image for each generated stack" );
		IJ.log( "--color-single-ch        -- Create colored single channels images, intead of gray ones" );
		System.exit(0);
	}

	// channels
	channels = new ArrayList();
	if( options.containsKey( "-ch" ) ) {
		channelOption = options.get("-ch");
		wantedChannels = channelOption.split(",");
		for (int i=0; i < wantedChannels.length; i++)
			channels.add( new Integer( wantedChannels[ i ].trim() ).intValue() );
		IJ.log( "Using channels: " + channels.toString() );
	} else {
		// add default channels
		IJ.log("Using default channels: [1, 2, 3, 4, 5]");
		channels.add(1);
		channels.add(2);
		channels.add(3);
		channels.add(4);
		channels.add(5);
		numChannels = channels.size();
	}

	// channel colors
	colors = new ArrayList();
	if( options.containsKey( "-clr" ) ) {
		colorOption = options.get("-clr");
		wantedColors = colorOption.split(",");
		for (int i=0; i < wantedColors.length; i++)
			colors.add( wantedColors[ i ].trim() );
		IJ.log( "Using colors: " + colors.toString() );
	} else {
		// add default colors if file was not found
		colors.add("Blue");
		colors.add("Green");
		colors.add("Magenta");
		colors.add("Grays");
		IJ.log("Using default colors: [Blue, Green, Magenta, Grays]");
	}

	// generated info YAML file -- default: false
	useGeneratedInfo = options.containsKey( "gen-info" );

	// create Z projections -- default: false
	createZProjections = options.containsKey( "z-project" );

	// gray scale for single channels -- default: true
	grayscaleSingleChannels = ! options.containsKey( "color-single-ch" );

	// max value for dynamic range adjustment -- default: 4095
	if ( options.containsKey( "-max-val" ) ) {
		maxValue = new Integer( options.get( "-max-val" ) ).intValue();
	} else {
		maxValue = 4095;
	}

	// input file -- default totile.txt
	if ( options.containsKey( "-input" ) ) {
		inputFile = options.get( "-input" );
	} else {
		inputFile = stackDirName = "totile.txt";
	}


	// target directory -- default: ./tile_output/
	if ( options.containsKey( "-target-dir" ) ) {
		stackDirName = options.get( "-target-dir" );
	} else {
		stackDirName = "./tile_output/";
	}
}

////////////// main ////////////////

// a place to keep our options
options = new HashMap();

singleFile = null;
// CL argument based on: http://stackoverflow.com/questions/7341683
for (int i; i < bsh.args.length; i++) {
	switch (bsh.args[i].charAt(0)) {
	case '-':
		if (bsh.args[i].length() < 2)
			throw new IllegalArgumentException("Not a valid argument: "+bsh.args[i]);
		if (bsh.args[i].charAt(1) == '-') {
				if (bsh.args[i].length() < 3)
					throw new IllegalArgumentException("Not a valid argument: "+bsh.args[i]);
				// --opt
				options.put( bsh.args[i].substring(2, bsh.args[i].length() ), "" );
			} else {
				if (bsh.args.length - 1 == i)
					throw new IllegalArgumentException("Expected arg after: "+bsh.args[i]);
				// -opt
				options.put( bsh.args[i], bsh.args[i+1] );
				i++;
			}
			break;

	default:
		if (args.length-1 == i)
			singleFile = bsh.args[ i ];
	}
}

// parse arguments
setup( options );
// start tile creation
work();
// end
IJ.log( "Done." );

